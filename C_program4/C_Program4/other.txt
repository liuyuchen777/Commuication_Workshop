	/* generate H */
	for (m = 0; m < N; m++)
	{
		temp.real = 0.0;
		temp.image = 0.0;
		for (d = 0; d < PATH_NUMBER; d++)
		{
			temp.real += h[d].real * cos(-2 * PI * m * d / N) - h[d].image * sin(-2 * PI * m * d / N);
			temp.image += h[d].image * cos(-2 * PI * m * d / N) + h[d].real * sin(-2 * PI * m * d / N);
		}
		H[m].real = temp.real;
		H[m].image = temp.image;
	}
	/* channel equalizer */
	for (m = 0; m < SYMBOLN; m++)
	{
		/* initialize */
		temp.real = 0.0;
		temp.image = 0.0;
		norm = 0.0;
		/* equalize */
		norm = pow(H[m].real, 2.0) + pow(H[m].image, 2.0);
		temp.real = R[m].real * H[m].real + R[m].image * R[m].image;
		temp.image = R[m].image * H[m].real - R[m].real * H[m].image;
		R[m].real = temp.real / norm;
		R[m].image = temp.image / norm;
	}